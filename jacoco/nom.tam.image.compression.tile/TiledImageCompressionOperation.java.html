<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TiledImageCompressionOperation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.image.compression.tile</a> &gt; <span class="el_source">TiledImageCompressionOperation.java</span></div><h1>TiledImageCompressionOperation.java</h1><pre class="source lang-java linenums">package nom.tam.image.compression.tile;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2015 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

import static nom.tam.fits.header.Compression.COMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.GZIP_COMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.UNCOMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.ZBITPIX;
import static nom.tam.fits.header.Compression.ZCMPTYPE;
import static nom.tam.fits.header.Compression.ZCMPTYPE_GZIP_1;
import static nom.tam.fits.header.Compression.ZNAXIS;
import static nom.tam.fits.header.Compression.ZNAXISn;
import static nom.tam.fits.header.Compression.ZQUANTIZ;
import static nom.tam.fits.header.Compression.ZTILEn;
import static nom.tam.fits.header.Standard.TTYPEn;
import static nom.tam.image.compression.tile.TileCompressionType.COMPRESSED;
import static nom.tam.image.compression.tile.TileCompressionType.GZIP_COMPRESSED;
import static nom.tam.image.compression.tile.TileCompressionType.UNCOMPRESSED;

import java.lang.reflect.Array;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;

import nom.tam.fits.BinaryTable;
import nom.tam.fits.BinaryTableHDU;
import nom.tam.fits.FitsException;
import nom.tam.fits.FitsFactory;
import nom.tam.fits.Header;
import nom.tam.fits.HeaderCard;
import nom.tam.fits.HeaderCardBuilder;
import nom.tam.fits.HeaderCardException;
import nom.tam.fits.compression.algorithm.api.ICompressOption;
import nom.tam.fits.compression.algorithm.api.ICompressorControl;
import nom.tam.fits.compression.provider.CompressorProvider;
import nom.tam.image.tile.operation.AbstractTiledImageOperation;
import nom.tam.image.tile.operation.TileArea;
import nom.tam.util.type.PrimitiveTypeHandler;

/**
 * This class represents a complete tiledImageOperation of tileOperations
 * describing an image ordered from left to right and top down. the
 * tileOperations all have the same geometry only the tileOperations at the
 * right side and the bottom side can have different sizes.
 */
public class TiledImageCompressionOperation extends AbstractTiledImageOperation&lt;TileCompressionOperation&gt; {

    /**
     * ZCMPTYPE name of the algorithm that was used to compress
     */
    private String compressAlgorithm;

    private final BinaryTable binaryTable;

    private ByteBuffer compressedWholeArea;

    // Note: field is initialized lazily: use getter within class!
    private ICompressorControl compressorControl;

    // Note: field is initialized lazily: use getter within class!
    private ICompressorControl gzipCompressorControl;

    /**
     * ZQUANTIZ name of the algorithm that was used to quantize
     */
    private String quantAlgorithm;

    private ICompressOption imageOptions;

    private static void addColumnToTable(BinaryTableHDU hdu, Object column, String columnName) throws FitsException {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (column != null) {</span>
<span class="fc" id="L102">            hdu.setColumnName(hdu.addColumn(column) - 1, columnName, null);</span>
        }
<span class="fc" id="L104">    }</span>

    private static void setNullEntries(Object column, Object defaultValue) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (column != null) {</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            for (int index = 0; index &lt; Array.getLength(column); index++) {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (Array.get(column, index) == null) {</span>
<span class="fc" id="L110">                    Array.set(column, index, defaultValue);</span>
                }
            }
        }
<span class="fc" id="L114">    }</span>

    /**
     * create a TiledImageCompressionOperation based on a compressed image data.
     *
     * @param binaryTable
     *            the compressed image data.
     */
    public TiledImageCompressionOperation(BinaryTable binaryTable) {
<span class="fc" id="L123">        super(TileCompressionOperation.class);</span>
<span class="fc" id="L124">        this.binaryTable = binaryTable;</span>
<span class="fc" id="L125">    }</span>

    public void compress(BinaryTableHDU hdu) throws FitsException {
<span class="fc" id="L128">        processAllTiles();</span>
<span class="fc" id="L129">        writeColumns(hdu);</span>
<span class="fc" id="L130">        writeHeader(hdu.getHeader());</span>
<span class="fc" id="L131">    }</span>

    public ICompressOption compressOptions() {
<span class="fc" id="L134">        initializeCompressionControl();</span>
<span class="fc" id="L135">        return this.imageOptions;</span>
    }

    public Buffer decompress() {
<span class="fc" id="L139">        Buffer decompressedWholeArea = getBaseType().newBuffer(getBufferSize());</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L141">            tileOperation.setWholeImageBuffer(decompressedWholeArea);</span>
        }
<span class="fc" id="L143">        processAllTiles();</span>
<span class="fc" id="L144">        decompressedWholeArea.rewind();</span>
<span class="fc" id="L145">        return decompressedWholeArea;</span>
    }

    public void forceNoLoss(int x, int y, int width, int heigth) {
<span class="fc" id="L149">        TileArea tileArea = new TileArea().start(x, y).end(x + width, y + heigth);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (TileCompressionOperation operation : getTileOperations()) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (operation.getArea().intersects(tileArea)) {</span>
<span class="fc" id="L152">                operation.forceNoLoss(true);</span>
            }
        }
<span class="fc" id="L155">    }</span>

    public TiledImageCompressionOperation prepareUncompressedData(final Buffer buffer) {
<span class="fc" id="L158">        this.compressedWholeArea = ByteBuffer.wrap(new byte[getBaseType().size() * getBufferSize()]);</span>
<span class="fc" id="L159">        createTiles(new TileCompressorInitialisation(this, buffer));</span>
<span class="fc" id="L160">        this.compressedWholeArea.rewind();</span>
<span class="fc" id="L161">        return this;</span>
    }

    public TiledImageCompressionOperation read(final Header header) throws FitsException {
<span class="fc" id="L165">        readPrimaryHeaders(header);</span>
<span class="fc" id="L166">        setCompressAlgorithm(header.findCard(ZCMPTYPE));</span>
<span class="fc" id="L167">        setQuantAlgorithm(header.findCard(ZQUANTIZ));</span>
<span class="fc" id="L168">        createTiles(new TileDecompressorInitialisation(this, //</span>
                getNullableColumn(header, Object[].class, UNCOMPRESSED_DATA_COLUMN), //
                getNullableColumn(header, Object[].class, COMPRESSED_DATA_COLUMN), //
                getNullableColumn(header, Object[].class, GZIP_COMPRESSED_DATA_COLUMN), //
                header));
<span class="fc" id="L173">        readCompressionHeaders(header);</span>
<span class="fc" id="L174">        return this;</span>
    }

    public void readPrimaryHeaders(Header header) throws FitsException {
<span class="fc" id="L178">        readBaseType(header);</span>
<span class="fc" id="L179">        readAxis(header);</span>
<span class="fc" id="L180">        readTileAxis(header);</span>
<span class="fc" id="L181">    }</span>

    public TiledImageCompressionOperation setCompressAlgorithm(HeaderCard compressAlgorithmCard) {
<span class="fc" id="L184">        this.compressAlgorithm = compressAlgorithmCard.getValue();</span>
<span class="fc" id="L185">        return this;</span>
    }

    public TiledImageCompressionOperation setQuantAlgorithm(HeaderCard quantAlgorithmCard) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (quantAlgorithmCard != null) {</span>
<span class="fc" id="L190">            this.quantAlgorithm = quantAlgorithmCard.getValue();</span>
        } else {
<span class="fc" id="L192">            this.quantAlgorithm = null;</span>
        }
<span class="fc" id="L194">        return this;</span>
    }

    private &lt;T&gt; T getNullableColumn(Header header, Class&lt;T&gt; class1, String columnName) throws FitsException {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (int i = 1; i &lt;= this.binaryTable.getNCols(); i++) {</span>
<span class="fc" id="L199">            String val = header.getStringValue(TTYPEn.n(i));</span>
<span class="pc bpc" id="L200" title="1 of 4 branches missed.">            if (val != null &amp;&amp; val.trim().equals(columnName)) {</span>
<span class="fc" id="L201">                return class1.cast(this.binaryTable.getColumn(i - 1));</span>
            }
        }
<span class="fc" id="L204">        return null;</span>
    }

    private void initializeCompressionControl() {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (this.compressorControl == null) {</span>
<span class="fc" id="L209">            this.compressorControl = CompressorProvider.findCompressorControl(this.quantAlgorithm, this.compressAlgorithm, getBaseType().primitiveClass());</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            if (this.compressorControl == null) {</span>
<span class="nc" id="L211">                throw new IllegalStateException(&quot;Found no compressor control for compression algorithm:&quot; + this.compressAlgorithm + //</span>
                        &quot; (quantize algorithm = &quot; + this.quantAlgorithm + &quot;, base type = &quot; + getBaseType().primitiveClass() + &quot;)&quot;);
            }
<span class="fc" id="L214">            initImageOptions();</span>
        }
<span class="fc" id="L216">    }</span>

    private void initImageOptions() {
<span class="fc" id="L219">        this.imageOptions = this.compressorControl.option();</span>
<span class="fc" id="L220">        initializeQuantAlgorithm();</span>
<span class="fc" id="L221">        this.imageOptions.getCompressionParameters().initializeColumns(getNumberOfTileOperations());</span>
<span class="fc" id="L222">    }</span>

    private void processAllTiles() {
<span class="fc" id="L225">        ExecutorService threadPool = FitsFactory.threadPool();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L227">            tileOperation.execute(threadPool);</span>
        }
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L230">            tileOperation.waitForResult();</span>
        }
<span class="fc" id="L232">    }</span>

    private void readAxis(Header header) throws FitsException {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (areAxesDefined()) {</span>
<span class="fc" id="L236">            int naxis = header.getIntValue(ZNAXIS);</span>
<span class="fc" id="L237">            int[] axes = new int[naxis];</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            for (int i = 1; i &lt;= naxis; i++) {</span>
<span class="fc" id="L239">                int axisValue = header.getIntValue(ZNAXISn.n(i), -1);</span>
<span class="fc" id="L240">                axes[i - 1] = axisValue;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (axes[i - 1] == -1) {</span>
<span class="fc" id="L242">                    throw new FitsException(&quot;Required ZNAXISn not found&quot;);</span>
                }
            }
<span class="fc" id="L245">            setAxes(axes);</span>
        }
<span class="fc" id="L247">    }</span>

    private void readBaseType(Header header) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (getBaseType() == null) {</span>
<span class="fc" id="L251">            setBaseType(PrimitiveTypeHandler.valueOf(header.getIntValue(ZBITPIX)));</span>
        }
<span class="fc" id="L253">    }</span>

    private void readCompressionHeaders(Header header) {
<span class="fc" id="L256">        compressOptions().getCompressionParameters().getValuesFromHeader(header);</span>
<span class="fc" id="L257">    }</span>

    private void readTileAxis(Header header) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (areTileAxesDefined()) {</span>
<span class="fc" id="L261">            int[] tileAxes = new int[getNAxes()];</span>
<span class="fc" id="L262">            Arrays.fill(tileAxes, 1);</span>
<span class="fc" id="L263">            tileAxes[0] = -1;</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            for (int i = 1; i &lt;= tileAxes.length; i++) {</span>
<span class="fc" id="L265">                HeaderCard card = header.findCard(ZTILEn.n(i));</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (card != null) {</span>
<span class="fc" id="L267">                    tileAxes[i - 1] = card.getValue(Integer.class, -1);</span>
                }
            }
<span class="fc" id="L270">            setTileAxes(tileAxes);</span>
        }
<span class="fc" id="L272">    }</span>

    private &lt;T&gt; Object setInColumn(Object column, boolean predicate, TileCompressionOperation tileOperation, Class&lt;T&gt; clazz, T value) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (predicate) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (column == null) {</span>
<span class="fc" id="L277">                column = Array.newInstance(clazz, getNumberOfTileOperations());</span>
            }
<span class="fc" id="L279">            Array.set(column, tileOperation.getTileIndex(), value);</span>
        }
<span class="fc" id="L281">        return column;</span>
    }

    private void writeColumns(BinaryTableHDU hdu) throws FitsException {
<span class="fc" id="L285">        Object compressedColumn = null;</span>
<span class="fc" id="L286">        Object uncompressedColumn = null;</span>
<span class="fc" id="L287">        Object gzipColumn = null;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L289">            TileCompressionType compression = tileOperation.getCompressionType();</span>
<span class="fc" id="L290">            byte[] compressedData = tileOperation.getCompressedData();</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">            compressedColumn = setInColumn(compressedColumn, compression == COMPRESSED, tileOperation, byte[].class, compressedData);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            gzipColumn = setInColumn(gzipColumn, compression == GZIP_COMPRESSED, tileOperation, byte[].class, compressedData);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">            uncompressedColumn = setInColumn(uncompressedColumn, compression == UNCOMPRESSED, tileOperation, byte[].class, compressedData);</span>
        }
<span class="fc" id="L296">        setNullEntries(compressedColumn, new byte[0]);</span>
<span class="fc" id="L297">        setNullEntries(gzipColumn, new byte[0]);</span>
<span class="fc" id="L298">        setNullEntries(uncompressedColumn, new byte[0]);</span>
<span class="fc" id="L299">        addColumnToTable(hdu, compressedColumn, COMPRESSED_DATA_COLUMN);</span>
<span class="fc" id="L300">        addColumnToTable(hdu, gzipColumn, GZIP_COMPRESSED_DATA_COLUMN);</span>
<span class="fc" id="L301">        addColumnToTable(hdu, uncompressedColumn, UNCOMPRESSED_DATA_COLUMN);</span>

<span class="fc" id="L303">        this.imageOptions.getCompressionParameters().addColumnsToTable(hdu);</span>
<span class="fc" id="L304">        hdu.getData().fillHeader(hdu.getHeader());</span>
<span class="fc" id="L305">    }</span>

    private void writeHeader(Header header) throws FitsException {
<span class="fc" id="L308">        HeaderCardBuilder cardBuilder = header//</span>
                .card(ZBITPIX).value(getBaseType().bitPix())//
                .card(ZCMPTYPE).value(this.compressAlgorithm);
<span class="fc" id="L311">        int[] tileAxes = getTileAxes();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int i = 1; i &lt;= tileAxes.length; i++) {</span>
<span class="fc" id="L313">            cardBuilder.card(ZTILEn.n(i)).value(tileAxes[i - 1]);</span>
        }
<span class="fc" id="L315">        compressOptions().getCompressionParameters().setValuesInHeader(header);</span>
<span class="fc" id="L316">    }</span>

    protected BinaryTable getBinaryTable() {
<span class="fc" id="L319">        return this.binaryTable;</span>
    }

    protected ByteBuffer getCompressedWholeArea() {
<span class="fc" id="L323">        return this.compressedWholeArea;</span>
    }

    protected ICompressorControl getCompressorControl() {
<span class="fc" id="L327">        initializeCompressionControl();</span>
<span class="fc" id="L328">        return this.compressorControl;</span>
    }

    protected ICompressorControl getGzipCompressorControl() {
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (this.gzipCompressorControl == null) {</span>
<span class="fc" id="L333">            this.gzipCompressorControl = CompressorProvider.findCompressorControl(null, ZCMPTYPE_GZIP_1, getBaseType().primitiveClass());</span>
        }
<span class="fc" id="L335">        return this.gzipCompressorControl;</span>
    }

    /**
     * very bad design but necessary for now. we need deep access to an
     * parameter.
     */
    protected void initializeQuantAlgorithm() {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (this.quantAlgorithm != null) {</span>
            try {
<span class="fc" id="L345">                Header header = new Header();</span>
<span class="fc" id="L346">                header.addValue(ZQUANTIZ, this.quantAlgorithm);</span>
<span class="fc" id="L347">                this.imageOptions.getCompressionParameters().getValuesFromHeader(header);</span>
<span class="nc" id="L348">            } catch (HeaderCardException e) {</span>
<span class="nc" id="L349">                throw new IllegalStateException(&quot;this should not happen&quot;, e);</span>
<span class="fc" id="L350">            }</span>
        }
<span class="fc" id="L352">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>