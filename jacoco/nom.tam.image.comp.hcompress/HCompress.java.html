<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HCompress.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.image.comp.hcompress</a> &gt; <span class="el_source">HCompress.java</span></div><h1>HCompress.java</h1><pre class="source lang-java linenums">package nom.tam.image.comp.hcompress;

import java.nio.ByteBuffer;

import nom.tam.util.ArrayFuncs;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2015 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

<span class="fc" id="L38">public abstract class HCompress {</span>

<span class="fc" id="L40">    private static class IntHCompress extends HCompress {</span>

        @Override
        protected void compress(Object array, int ny, int nx, int scale, ByteBuffer compressed) {
<span class="fc" id="L44">            int[] intArray = (int[]) array;</span>
<span class="fc" id="L45">            long[] longArray = new long[intArray.length];</span>
<span class="fc" id="L46">            ArrayFuncs.copyInto(intArray, longArray);</span>
<span class="fc" id="L47">            compress(longArray, ny, nx, scale, compressed);</span>
<span class="fc" id="L48">        }</span>
    }

<span class="fc" id="L51">    private static class ShortHCompress extends HCompress {</span>

        @Override
        protected void compress(Object array, int ny, int nx, int scale, ByteBuffer compressed) {
<span class="fc" id="L55">            short[] shortArray = (short[]) array;</span>
<span class="fc" id="L56">            long[] longArray = new long[shortArray.length];</span>
<span class="fc" id="L57">            ArrayFuncs.copyInto(shortArray, longArray);</span>
<span class="fc" id="L58">            compress(longArray, ny, nx, scale, compressed);</span>
<span class="fc" id="L59">        }</span>
    }

<span class="fc" id="L62">    private static class ByteHCompress extends HCompress {</span>

        private static final long BYTE_MASK_FOR_LONG = 0xFFL;

        @Override
        protected void compress(Object array, int ny, int nx, int scale, ByteBuffer compressed) {
<span class="fc" id="L68">            byte[] byteArray = (byte[]) array;</span>
<span class="fc" id="L69">            long[] longArray = new long[byteArray.length];</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            for (int index = 0; index &lt; longArray.length; index++) {</span>
<span class="fc" id="L71">                longArray[index] = byteArray[index] &amp; BYTE_MASK_FOR_LONG;</span>
            }
<span class="fc" id="L73">            compress(longArray, ny, nx, scale, compressed);</span>
<span class="fc" id="L74">        }</span>
    }

<span class="fc" id="L77">    private static class LongArrayPointer {</span>

        private long[] a;

        private int offset;

        public LongArrayPointer copy() {
<span class="fc" id="L84">            LongArrayPointer intAP = new LongArrayPointer();</span>
<span class="fc" id="L85">            intAP.a = this.a;</span>
<span class="fc" id="L86">            intAP.offset = this.offset;</span>
<span class="fc" id="L87">            return intAP;</span>
        }

        public LongArrayPointer copy(int extraOffset) {
<span class="fc" id="L91">            LongArrayPointer intAP = new LongArrayPointer();</span>
<span class="fc" id="L92">            intAP.a = this.a;</span>
<span class="fc" id="L93">            intAP.offset = this.offset + extraOffset;</span>
<span class="fc" id="L94">            return intAP;</span>
        }

        public long get() {
<span class="fc" id="L98">            return this.a[this.offset];</span>
        }

        public long get(int i) {
<span class="fc" id="L102">            return this.a[this.offset + i];</span>
        }

        public void set(int i, long value) {
<span class="fc" id="L106">            this.a[this.offset + i] = value;</span>

<span class="fc" id="L108">        }</span>

        public void set(long value) {
<span class="fc" id="L111">            this.a[this.offset] = value;</span>
<span class="fc" id="L112">        }</span>

    }

    private static final int HTRANS_START_MASK = -2;

    protected static final double ROUNDING_HALF = 0.5;

    protected static final int BITS_OF_1_BYTE = 8;

    protected static final int BITS_OF_1_NYBBLE = 4;

    protected static final int BYTE_MASK = 0xff;

    protected static final int NYBBLE_MASK = 0xF;

    /**
     * to be refactored to a good name.
     */
    private static final int N3 = 3;

<span class="fc" id="L133">    private static final int[] BITS_MASK = {</span>
        0,
        1,
        3,
        7,
        15,
        31,
        63,
        127,
        255
    };

    /*
     * Huffman code values and number of bits in each code
     */
<span class="fc" id="L148">    private static final int[] CODE = {</span>
        0x3e,
        0x00,
        0x01,
        0x08,
        0x02,
        0x09,
        0x1a,
        0x1b,
        0x03,
        0x1c,
        0x0a,
        0x1d,
        0x0b,
        0x1e,
        0x3f,
        0x0c
    };

<span class="fc" id="L167">    private static final byte[] CODE_MAGIC = {</span>
        (byte) 0xDD,
        (byte) 0x99
    };

<span class="fc" id="L172">    private static final int[] NCODE = {</span>
        6,
        3,
        3,
        4,
        3,
        4,
        5,
        5,
        3,
        5,
        4,
        5,
        4,
        5,
        6,
        4
    };

    /*
     * htrans.c H-transform of NX x NY integer image Programmer: R. White Date:
     * 11 May 1992
     */

    public static HCompress createCompressor(Object data) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (data instanceof int[]) {</span>
<span class="fc" id="L198">            return new IntHCompress();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        } else if (data instanceof short[]) {</span>
<span class="fc" id="L200">            return new ShortHCompress();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        } else if (data instanceof byte[]) {</span>
<span class="fc" id="L202">            return new ByteHCompress();</span>
        }
<span class="nc" id="L204">        return null;</span>
    }

    /**
     * variables for bit output to buffer when Huffman coding
     */
    private int bitbuffer;

    /** Number of bits free in buffer */
    private int bitsToGo2;

    private int bitsToGo3;

    /** Bits buffered for output */
    private int buffer2;

    private int b2i(boolean b) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        return b ? 1 : 0;</span>
    }

    private int bufcopy(byte[] a, int n, byte[] buffer, int b, long bmax) {
        int i;

<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (a[i] != 0) {</span>
                /*
                 * add Huffman code for a[i] to buffer
                 */
<span class="fc" id="L232">                this.bitbuffer |= CODE[a[i]] &lt;&lt; this.bitsToGo3;</span>
<span class="fc" id="L233">                this.bitsToGo3 += NCODE[a[i]];</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                if (this.bitsToGo3 &gt;= BITS_OF_1_BYTE) {</span>
<span class="fc" id="L235">                    buffer[b] = (byte) (this.bitbuffer &amp; BYTE_MASK);</span>
<span class="fc" id="L236">                    b += 1;</span>
                    /*
                     * return warning code if we fill buffer
                     */
<span class="fc bfc" id="L240" title="All 2 branches covered.">                    if (b &gt;= bmax) {</span>
<span class="fc" id="L241">                        return b;</span>
                    }
<span class="fc" id="L243">                    this.bitbuffer &gt;&gt;= BITS_OF_1_BYTE;</span>
<span class="fc" id="L244">                    this.bitsToGo3 -= BITS_OF_1_BYTE;</span>
                }
            }
        }
<span class="fc" id="L248">        return b;</span>
    }

    protected void compress(long[] aa, int ny, int nx, int scale, ByteBuffer output) {
        /*
         * compress the input image using the H-compress algorithm a - input
         * image array nx - size of X axis of image ny - size of Y axis of image
         * scale - quantization scale factor. Larger values results in more
         * (lossy) compression scale = 0 does lossless compression output -
         * pre-allocated array to hold the output compressed stream of bytes
         * nbyts - input value = size of the output buffer; returned value =
         * size of the compressed byte stream, in bytes NOTE: the nx and ny
         * dimensions as defined within this code are reversed from the usual
         * FITS notation. ny is the fastest varying dimension, which is usually
         * considered the X axis in the FITS image display
         */

        /* H-transform */
<span class="fc" id="L266">        htrans(aa, nx, ny);</span>

<span class="fc" id="L268">        LongArrayPointer a = new LongArrayPointer();</span>
<span class="fc" id="L269">        a.a = aa;</span>
<span class="fc" id="L270">        a.offset = 0;</span>

        /* digitize */
<span class="fc" id="L273">        digitize(a, 0, nx, ny, scale);</span>

        /* encode and write to output array */
<span class="fc" id="L276">        encode(output, a, nx, ny, scale);</span>

<span class="fc" id="L278">    }</span>

    protected abstract void compress(Object aa, int ny, int nx, int scale, ByteBuffer output);

    private void digitize(LongArrayPointer a, int aOffset, int nx, int ny, long scale) {
        long d;
        LongArrayPointer p;

        /*
         * round to multiple of scale
         */
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (scale &lt;= 1) {</span>
<span class="fc" id="L290">            return;</span>
        }
<span class="fc" id="L292">        d = (scale + 1L) / 2L - 1L;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int index = 0; index &lt; a.a.length; index++) {</span>
<span class="fc" id="L294">            long current = a.get(index);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            a.set(index, (current &gt; 0 ? current + d : current - d) / scale);</span>
        }
<span class="fc" id="L297">    }</span>

    private void doencode(ByteBuffer outfile, LongArrayPointer a, int nx, int ny, byte[] nbitplanes) {
        /*
         * char *outfile; output data stream int a[]; Array of values to encode
         * int nx,ny; Array dimensions [nx][ny] unsigned char nbitplanes[3];
         * Number of bit planes in quadrants
         */

        int nx2, ny2;

<span class="fc" id="L308">        nx2 = (nx + 1) / 2;</span>
<span class="fc" id="L309">        ny2 = (ny + 1) / 2;</span>
        /*
         * Initialize bit output
         */
<span class="fc" id="L313">        startOutputingBits();</span>
        /*
         * write out the bit planes for each quadrant
         */
<span class="fc" id="L317">        qtreeEncode(outfile, a.copy(), ny, nx2, ny2, nbitplanes[0]);</span>

<span class="fc" id="L319">        qtreeEncode(outfile, a.copy(ny2), ny, nx2, ny / 2, nbitplanes[1]);</span>

<span class="fc" id="L321">        qtreeEncode(outfile, a.copy(ny * nx2), ny, nx / 2, ny2, nbitplanes[1]);</span>

<span class="fc" id="L323">        qtreeEncode(outfile, a.copy(ny * nx2 + ny2), ny, nx / 2, ny / 2, nbitplanes[2]);</span>
        /*
         * Add zero as an EOF symbol
         */
<span class="fc" id="L327">        outputNybble(outfile, 0);</span>
<span class="fc" id="L328">        doneOutputingBits(outfile);</span>

<span class="fc" id="L330">    }</span>

    private void doneOutputingBits(ByteBuffer outfile) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (this.bitsToGo2 &lt; BITS_OF_1_BYTE) {</span>
            /* putc(buffer2&lt;&lt;bits_to_go2,outfile); */

<span class="fc" id="L336">            outfile.put((byte) (this.buffer2 &lt;&lt; this.bitsToGo2));</span>
        }
<span class="fc" id="L338">    }</span>

    private int encode(ByteBuffer outfile, LongArrayPointer a, int nx, int ny, int scale) {

        /* FILE *outfile; - change outfile to a char array */
        /*
         * long * nlength returned length (in bytes) of the encoded array) int
         * a[]; input H-transform array (nx,ny) int nx,ny; size of H-transform
         * array int scale; scale factor for digitization
         */
        int nel, nx2, ny2, i, j, k, q, nsign, bitsToGo;
<span class="fc" id="L349">        long[] vmax = new long[N3];</span>
<span class="fc" id="L350">        byte[] nbitplanes = new byte[N3];</span>
        byte[] signbits;

<span class="fc" id="L353">        long noutchar = 0; /*</span>
                            * initialize the number of compressed bytes that
                            * have been written
                            */
<span class="fc" id="L357">        nel = nx * ny;</span>
        /*
         * write magic value
         */
<span class="fc" id="L361">        outfile.put(CODE_MAGIC);</span>
<span class="fc" id="L362">        outfile.putInt(nx); /* size of image */</span>
<span class="fc" id="L363">        outfile.putInt(ny);</span>
<span class="fc" id="L364">        outfile.putInt(scale); /* scale factor for digitization */</span>
        /*
         * write first value of A (sum of all pixels -- the only value which
         * does not compress well)
         */
<span class="fc" id="L369">        outfile.putLong(a.get());</span>

<span class="fc" id="L371">        a.set(0);</span>
        /*
         * allocate array for sign bits and save values, 8 per byte
         */
<span class="fc" id="L375">        signbits = new byte[(nel + BITS_OF_1_BYTE - 1) / BITS_OF_1_BYTE];</span>

<span class="fc" id="L377">        nsign = 0;</span>
<span class="fc" id="L378">        bitsToGo = BITS_OF_1_BYTE;</span>
<span class="fc" id="L379">        signbits[0] = 0;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (i = 0; i &lt; nel; i++) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            if (a.get(i) &gt; 0) {</span>
                /*
                 * positive element, put zero at end of buffer
                 */
<span class="fc" id="L385">                signbits[nsign] &lt;&lt;= 1;</span>
<span class="fc" id="L386">                bitsToGo -= 1;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            } else if (a.get(i) &lt; 0) {</span>
                /*
                 * negative element, shift in a one
                 */
<span class="fc" id="L391">                signbits[nsign] &lt;&lt;= 1;</span>
<span class="fc" id="L392">                signbits[nsign] |= 1;</span>
<span class="fc" id="L393">                bitsToGo -= 1;</span>
                /*
                 * replace a by absolute value
                 */
<span class="fc" id="L397">                a.set(i, -a.get(i));</span>
            }
<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (bitsToGo == 0) {</span>
                /*
                 * filled up this byte, go to the next one
                 */
<span class="fc" id="L403">                bitsToGo = BITS_OF_1_BYTE;</span>
<span class="fc" id="L404">                nsign += 1;</span>
<span class="fc" id="L405">                signbits[nsign] = 0;</span>
            }
        }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (bitsToGo != BITS_OF_1_BYTE) {</span>
            /*
             * some bits in last element move bits in last byte to bottom and
             * increment nsign
             */
<span class="fc" id="L413">            signbits[nsign] &lt;&lt;= bitsToGo;</span>
<span class="fc" id="L414">            nsign += 1;</span>
        }
        /*
         * calculate number of bit planes for 3 quadrants quadrant 0=bottom
         * left, 1=bottom right or top left, 2=top right,
         */
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (q = 0; q &lt; N3; q++) {</span>
<span class="fc" id="L421">            vmax[q] = 0;</span>
        }
        /*
         * get maximum absolute value in each quadrant
         */
<span class="fc" id="L426">        nx2 = (nx + 1) / 2;</span>
<span class="fc" id="L427">        ny2 = (ny + 1) / 2;</span>
<span class="fc" id="L428">        j = 0; /* column counter */</span>
<span class="fc" id="L429">        k = 0; /* row counter */</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (i = 0; i &lt; nel; i++) {</span>
<span class="fc bfc" id="L431" title="All 4 branches covered.">            q = (j &gt;= ny2 ? 1 : 0) + (k &gt;= nx2 ? 1 : 0);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (vmax[q] &lt; a.get(i)) {</span>
<span class="fc" id="L433">                vmax[q] = a.get(i);</span>
            }
<span class="fc bfc" id="L435" title="All 2 branches covered.">            if (++j &gt;= ny) {</span>
<span class="fc" id="L436">                j = 0;</span>
<span class="fc" id="L437">                k += 1;</span>
            }
        }
        /*
         * now calculate number of bits for each quadrant
         */

        /* this is a more efficient way to do this, */

<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (q = 0; q &lt; N3; q++) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            for (nbitplanes[q] = 0; vmax[q] &gt; 0; vmax[q] = vmax[q] &gt;&gt; 1, nbitplanes[q]++) {</span>
                // noop for later refactoring
<span class="fc" id="L449">                &quot;&quot;.toString();</span>
            }
        }

        /*
         * write nbitplanes
         */
<span class="fc" id="L456">        outfile.put(nbitplanes, 0, nbitplanes.length);</span>

        /*
         * write coded array
         */
<span class="fc" id="L461">        doencode(outfile, a, nx, ny, nbitplanes);</span>
        /*
         * write sign bits
         */

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (nsign &gt; 0) {</span>
<span class="fc" id="L467">            outfile.put(signbits, 0, nsign);</span>
        }

<span class="fc" id="L470">        return (int) noutchar;</span>

    }

    private int htrans(long[] a, int nx, int ny) {
        int nmax, log2n, nxtop, nytop, i, j, k;
        int oddx, oddy;
        int s10, s00;
        long h0, hx, hy, hc, shift, mask, mask2, prnd, prnd2, nrnd2;
        long[] tmp;

        /*
         * log2n is log2 of max(nx,ny) rounded up to next power of 2
         */
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        nmax = nx &gt; ny ? nx : ny;</span>
<span class="fc" id="L485">        log2n = log2n(nmax);</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (nmax &gt; 1 &lt;&lt; log2n) {</span>
<span class="nc" id="L487">            log2n += 1;</span>
        }
        /*
         * get temporary storage for shuffling elements
         */
<span class="fc" id="L492">        tmp = new long[(nmax + 1) / 2];</span>

        /*
         * set up rounding and shifting masks
         */
<span class="fc" id="L497">        shift = 0;</span>
<span class="fc" id="L498">        mask = HTRANS_START_MASK;</span>
<span class="fc" id="L499">        mask2 = mask &lt;&lt; 1;</span>
<span class="fc" id="L500">        prnd = 1;</span>
<span class="fc" id="L501">        prnd2 = prnd &lt;&lt; 1;</span>
<span class="fc" id="L502">        nrnd2 = prnd2 - 1;</span>
        /*
         * do log2n reductions We're indexing a as a 2-D array with dimensions
         * (nx,ny).
         */
<span class="fc" id="L507">        nxtop = nx;</span>
<span class="fc" id="L508">        nytop = ny;</span>

<span class="fc bfc" id="L510" title="All 2 branches covered.">        for (k = 0; k &lt; log2n; k++) {</span>
<span class="fc" id="L511">            oddx = nxtop % 2;</span>
<span class="fc" id="L512">            oddy = nytop % 2;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">            for (i = 0; i &lt; nxtop - oddx; i += 2) {</span>
<span class="fc" id="L514">                s00 = i * ny; /* s00 is index of a[i,j] */</span>
<span class="fc" id="L515">                s10 = s00 + ny; /* s10 is index of a[i+1,j] */</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                for (j = 0; j &lt; nytop - oddy; j += 2) {</span>
                    /*
                     * Divide h0,hx,hy,hc by 2 (1 the first time through).
                     */
<span class="fc" id="L520">                    h0 = a[s10 + 1] + a[s10] + a[s00 + 1] + a[s00] &gt;&gt; shift;</span>
<span class="fc" id="L521">                    hx = a[s10 + 1] + a[s10] - a[s00 + 1] - a[s00] &gt;&gt; shift;</span>
<span class="fc" id="L522">                    hy = a[s10 + 1] - a[s10] + a[s00 + 1] - a[s00] &gt;&gt; shift;</span>
<span class="fc" id="L523">                    hc = a[s10 + 1] - a[s10] - a[s00 + 1] + a[s00] &gt;&gt; shift;</span>

                    /*
                     * Throw away the 2 bottom bits of h0, bottom bit of hx,hy.
                     * To get rounding to be same for positive and negative
                     * numbers, nrnd2 = prnd2 - 1.
                     */
<span class="fc" id="L530">                    a[s10 + 1] = hc;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                    a[s10] = (hx &gt;= 0 ? hx + prnd : hx) &amp; mask;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                    a[s00 + 1] = (hy &gt;= 0 ? hy + prnd : hy) &amp; mask;</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                    a[s00] = (h0 &gt;= 0 ? h0 + prnd2 : h0 + nrnd2) &amp; mask2;</span>
<span class="fc" id="L534">                    s00 += 2;</span>
<span class="fc" id="L535">                    s10 += 2;</span>
                }
<span class="fc bfc" id="L537" title="All 2 branches covered.">                if (oddy != 0) {</span>
                    /*
                     * do last element in row if row length is odd s00+1, s10+1
                     * are off edge
                     */
<span class="fc" id="L542">                    h0 = a[s10] + a[s00] &lt;&lt; 1 - shift;</span>
<span class="fc" id="L543">                    hx = a[s10] - a[s00] &lt;&lt; 1 - shift;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    a[s10] = (hx &gt;= 0 ? hx + prnd : hx) &amp; mask;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                    a[s00] = (h0 &gt;= 0 ? h0 + prnd2 : h0 + nrnd2) &amp; mask2;</span>
<span class="fc" id="L546">                    s00 += 1;</span>
<span class="fc" id="L547">                    s10 += 1;</span>
                }
            }
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (oddx != 0) {</span>
                /*
                 * do last row if column length is odd s10, s10+1 are off edge
                 */
<span class="fc" id="L554">                s00 = i * ny;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                for (j = 0; j &lt; nytop - oddy; j += 2) {</span>
<span class="fc" id="L556">                    h0 = a[s00 + 1] + a[s00] &lt;&lt; 1 - shift;</span>
<span class="fc" id="L557">                    hy = a[s00 + 1] - a[s00] &lt;&lt; 1 - shift;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                    a[s00 + 1] = (hy &gt;= 0 ? hy + prnd : hy) &amp; mask;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                    a[s00] = (h0 &gt;= 0 ? h0 + prnd2 : h0 + nrnd2) &amp; mask2;</span>
<span class="fc" id="L560">                    s00 += 2;</span>
                }
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                if (oddy != 0) {</span>
                    /*
                     * do corner element if both row and column lengths are odd
                     * s00+1, s10, s10+1 are off edge
                     */
<span class="fc" id="L567">                    h0 = a[s00] &lt;&lt; 2 - shift;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                    a[s00] = (h0 &gt;= 0 ? h0 + prnd2 : h0 + nrnd2) &amp; mask2;</span>
                }
            }
            /*
             * now shuffle in each dimension to group coefficients by order
             */
            // achtung eigenlich pointer nach a
<span class="fc bfc" id="L575" title="All 2 branches covered.">            for (i = 0; i &lt; nxtop; i++) {</span>
<span class="fc" id="L576">                shuffle(a, ny * i, nytop, 1, tmp);</span>
            }
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (j = 0; j &lt; nytop; j++) {</span>
<span class="fc" id="L579">                shuffle(a, j, nxtop, ny, tmp);</span>
            }
            /*
             * image size reduced by 2 (round up if odd)
             */
<span class="fc" id="L584">            nxtop = nxtop + 1 &gt;&gt; 1;</span>
<span class="fc" id="L585">            nytop = nytop + 1 &gt;&gt; 1;</span>
            /*
             * divisor doubles after first reduction
             */
<span class="fc" id="L589">            shift = 1;</span>
            /*
             * masks, rounding values double after each iteration
             */
<span class="fc" id="L593">            mask = mask2;</span>
<span class="fc" id="L594">            prnd = prnd2;</span>
<span class="fc" id="L595">            mask2 = mask2 &lt;&lt; 1;</span>
<span class="fc" id="L596">            prnd2 = prnd2 &lt;&lt; 1;</span>
<span class="fc" id="L597">            nrnd2 = prnd2 - 1;</span>
        }
<span class="fc" id="L599">        return 0;</span>
    }

    private int log2n(int nqmax) {
<span class="fc" id="L603">        return (int) (Math.log(nqmax) / Math.log(2.0) + ROUNDING_HALF);</span>
    }

    private void outputNbits(ByteBuffer outfile, int bits, int n) {
        /* AND mask for the right-most n bits */

        /*
         * insert bits at end of buffer
         */
<span class="fc" id="L612">        this.buffer2 &lt;&lt;= n;</span>
        /* buffer2 |= ( bits &amp; ((1&lt;&lt;n)-1) ); */
<span class="fc" id="L614">        this.buffer2 |= bits &amp; BITS_MASK[n];</span>
<span class="fc" id="L615">        this.bitsToGo2 -= n;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (this.bitsToGo2 &lt;= 0) {</span>
            /*
             * buffer2 full, put out top 8 bits
             */

<span class="fc" id="L621">            outfile.put((byte) (this.buffer2 &gt;&gt; -this.bitsToGo2 &amp; BYTE_MASK));</span>

<span class="fc" id="L623">            this.bitsToGo2 += BITS_OF_1_BYTE;</span>
        }
<span class="fc" id="L625">    }</span>

    private void outputNnybble(ByteBuffer outfile, int n, byte[] array) {
        /*
         * pack the 4 lower bits in each element of the array into the outfile
         * array
         */

<span class="fc" id="L633">        int ii, jj, kk = 0, shift;</span>

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (n == 1) {</span>
<span class="nc" id="L636">            outputNybble(outfile, array[0]);</span>
<span class="nc" id="L637">            return;</span>
        }
        /*
         * forcing byte alignment doesn;t help, and even makes it go slightly
         * slower if (bits_to_go2 != 8) output_nbits(outfile, kk, bits_to_go2);
         */
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if (this.bitsToGo2 &lt;= BITS_OF_1_NYBBLE) {</span>
            /* just room for 1 nybble; write it out separately */
<span class="fc" id="L645">            outputNybble(outfile, array[0]);</span>
<span class="fc" id="L646">            kk++; /* index to next array element */</span>

<span class="pc bpc" id="L648" title="1 of 2 branches missed.">            if (n == 2) {</span>
                // only 1 more nybble to write out
<span class="nc" id="L650">                outputNybble(outfile, array[1]);</span>
<span class="nc" id="L651">                return;</span>
            }
        }

        /* bits_to_go2 is now in the range 5 - 8 */
<span class="fc" id="L656">        shift = BITS_OF_1_BYTE - this.bitsToGo2;</span>

        /*
         * now write out pairs of nybbles; this does not affect value of
         * bits_to_go2
         */
<span class="fc" id="L662">        jj = (n - kk) / 2;</span>

<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (this.bitsToGo2 == BITS_OF_1_BYTE) {</span>
            /* special case if nybbles are aligned on byte boundary */
            /* this actually seems to make very little differnece in speed */
<span class="fc" id="L667">            this.buffer2 = 0;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (ii = 0; ii &lt; jj; ii++) {</span>
<span class="fc" id="L669">                outfile.put((byte) ((array[kk] &amp; NYBBLE_MASK) &lt;&lt; BITS_OF_1_NYBBLE | array[kk + 1] &amp; NYBBLE_MASK));</span>
<span class="fc" id="L670">                kk += 2;</span>
            }
        } else {
<span class="fc bfc" id="L673" title="All 2 branches covered.">            for (ii = 0; ii &lt; jj; ii++) {</span>
<span class="fc" id="L674">                this.buffer2 = this.buffer2 &lt;&lt; BITS_OF_1_BYTE | (array[kk] &amp; NYBBLE_MASK) &lt;&lt; BITS_OF_1_NYBBLE | array[kk + 1] &amp; NYBBLE_MASK;</span>
<span class="fc" id="L675">                kk += 2;</span>

                /*
                 * buffer2 full, put out top 8 bits
                 */

<span class="fc" id="L681">                outfile.put((byte) (this.buffer2 &gt;&gt; shift &amp; BYTE_MASK));</span>
            }
        }

        /* write out last odd nybble, if present */
<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (kk != n) {</span>
<span class="fc" id="L687">            outputNybble(outfile, array[n - 1]);</span>
        }

<span class="fc" id="L690">        return;</span>
    }

    private void outputNybble(ByteBuffer outfile, int bits) {
        /*
         * insert 4 bits at end of buffer
         */
<span class="fc" id="L697">        this.buffer2 = this.buffer2 &lt;&lt; BITS_OF_1_NYBBLE | bits &amp; NYBBLE_MASK;</span>
<span class="fc" id="L698">        this.bitsToGo2 -= BITS_OF_1_NYBBLE;</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (this.bitsToGo2 &lt;= 0) {</span>
            /*
             * buffer2 full, put out top 8 bits
             */

<span class="fc" id="L704">            outfile.put((byte) (this.buffer2 &gt;&gt; -this.bitsToGo2 &amp; BYTE_MASK));</span>

<span class="fc" id="L706">            this.bitsToGo2 += BITS_OF_1_BYTE;</span>
        }
<span class="fc" id="L708">    }</span>

    /**
     * macros to write out 4-bit nybble, Huffman code for this value
     */
    private int qtreeEncode(ByteBuffer outfile, LongArrayPointer a, int n, int nqx, int nqy, int nbitplanes) {

        /*
         * int a[]; int n; physical dimension of row in a int nqx; length of row
         * int nqy; length of column (&lt;=n) int nbitplanes; number of bit planes
         * to output
         */

        int log2n, i, k, bit, b, nqmax, nqx2, nqy2, nx, ny;
        long bmax;
        byte[] scratch, buffer;

        /*
         * log2n is log2 of max(nqx,nqy) rounded up to next power of 2
         */
<span class="fc bfc" id="L728" title="All 2 branches covered.">        nqmax = nqx &gt; nqy ? nqx : nqy;</span>
<span class="fc" id="L729">        log2n = log2n(nqmax);</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        if (nqmax &gt; 1 &lt;&lt; log2n) {</span>
<span class="nc" id="L731">            log2n += 1;</span>
        }
        /*
         * initialize buffer point, max buffer size
         */
<span class="fc" id="L736">        nqx2 = (nqx + 1) / 2;</span>
<span class="fc" id="L737">        nqy2 = (nqy + 1) / 2;</span>
<span class="fc" id="L738">        bmax = (nqx2 * nqy2 + 1) / 2;</span>
        /*
         * We're indexing A as a 2-D array with dimensions (nqx,nqy). Scratch is
         * 2-D with dimensions (nqx/2,nqy/2) rounded up. Buffer is used to store
         * string of codes for output.
         */
<span class="fc" id="L744">        scratch = new byte[(int) (2 * bmax)];</span>
<span class="fc" id="L745">        buffer = new byte[(int) bmax];</span>

        /*
         * now encode each bit plane, starting with the top
         */
<span class="fc bfc" id="L750" title="All 2 branches covered.">        bitplane_done: for (bit = nbitplanes - 1; bit &gt;= 0; bit--) {</span>
            /*
             * initial bit buffer
             */
<span class="fc" id="L754">            b = 0;</span>
<span class="fc" id="L755">            this.bitbuffer = 0;</span>
<span class="fc" id="L756">            this.bitsToGo3 = 0;</span>
            /*
             * on first pass copy A to scratch array
             */
<span class="fc" id="L760">            qtreeOnebit(a, n, nqx, nqy, scratch, bit);</span>
<span class="fc" id="L761">            nx = nqx + 1 &gt;&gt; 1;</span>
<span class="fc" id="L762">            ny = nqy + 1 &gt;&gt; 1;</span>
            /*
             * copy non-zero values to output buffer, which will be written in
             * reverse order
             */
<span class="fc" id="L767">            b = bufcopy(scratch, nx * ny, buffer, b, bmax);</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">            if (b &gt;= bmax) {</span>
                /*
                 * quadtree is expanding data, change warning code and just fill
                 * buffer with bit-map
                 */
<span class="nc" id="L773">                writeBdirect(outfile, a, n, nqx, nqy, scratch, bit);</span>
<span class="nc" id="L774">                continue bitplane_done;</span>
            }
            /*
             * do log2n reductions
             */
<span class="fc bfc" id="L779" title="All 2 branches covered.">            for (k = 1; k &lt; log2n; k++) {</span>
<span class="fc" id="L780">                qtreeReduce(scratch, ny, nx, ny, scratch);</span>
<span class="fc" id="L781">                nx = nx + 1 &gt;&gt; 1;</span>
<span class="fc" id="L782">                ny = ny + 1 &gt;&gt; 1;</span>
<span class="fc" id="L783">                b = bufcopy(scratch, nx * ny, buffer, b, bmax);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">                if (b &gt;= bmax) {</span>
<span class="fc" id="L785">                    writeBdirect(outfile, a, n, nqx, nqy, scratch, bit);</span>
<span class="fc" id="L786">                    continue bitplane_done;</span>
                }
            }
            /*
             * OK, we've got the code in buffer Write quadtree warning code,
             * then write buffer in reverse order
             */
<span class="fc" id="L793">            outputNybble(outfile, NYBBLE_MASK);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">            if (b == 0) {</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">                if (this.bitsToGo3 &gt; 0) {</span>
                    /*
                     * put out the last few bits
                     */
<span class="nc" id="L799">                    outputNbits(outfile, this.bitbuffer &amp; (1 &lt;&lt; this.bitsToGo3) - 1, this.bitsToGo3);</span>
                } else {
                    /*
                     * have to write a zero nybble if there are no 1's in array
                     */
<span class="fc" id="L804">                    outputNbits(outfile, CODE[0], NCODE[0]);</span>
                }
            } else {
<span class="fc bfc" id="L807" title="All 2 branches covered.">                if (this.bitsToGo3 &gt; 0) {</span>
                    /*
                     * put out the last few bits
                     */
<span class="fc" id="L811">                    outputNbits(outfile, this.bitbuffer &amp; (1 &lt;&lt; this.bitsToGo3) - 1, this.bitsToGo3);</span>
                }
<span class="fc bfc" id="L813" title="All 2 branches covered.">                for (i = b - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L814">                    outputNbits(outfile, buffer[i], BITS_OF_1_BYTE);</span>
                }
            }
        }
<span class="fc" id="L818">        return 0;</span>
    }

    private void qtreeOnebit(LongArrayPointer a, int n, int nx, int ny, byte[] b, int bit) {
        int i, j, k;
        long b0, b1, b2, b3;
        int s10, s00;

        /*
         * use selected bit to get amount to shift
         */
<span class="fc" id="L829">        b0 = 1L &lt;&lt; bit;</span>
<span class="fc" id="L830">        b1 = b0 &lt;&lt; 1;</span>
<span class="fc" id="L831">        b2 = b1 &lt;&lt; 1;</span>
<span class="fc" id="L832">        b3 = b2 &lt;&lt; 1;</span>
<span class="fc" id="L833">        k = 0; /* k is index of b[i/2,j/2] */</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">        for (i = 0; i &lt; nx - 1; i += 2) {</span>
<span class="fc" id="L835">            s00 = n * i; /* s00 is index of a[i,j] */</span>
            /*
             * tried using s00+n directly in the statements, but this had no
             * effect on performance
             */
<span class="fc" id="L840">            s10 = s00 + n; /* s10 is index of a[i+1,j] */</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">            for (j = 0; j &lt; ny - 1; j += 2) {</span>

<span class="fc" id="L843">                b[k] = (byte) ((a.get(s10 + 1) &amp; b0 //</span>
                        | a.get(s10) &lt;&lt; 1 &amp; b1 //
                        | a.get(s00 + 1) &lt;&lt; 2 &amp; b2 //
                | a.get(s00) &lt;&lt; N3 &amp; b3) &gt;&gt; bit);

<span class="fc" id="L848">                k += 1;</span>
<span class="fc" id="L849">                s00 += 2;</span>
<span class="fc" id="L850">                s10 += 2;</span>
            }
<span class="fc bfc" id="L852" title="All 2 branches covered.">            if (j &lt; ny) {</span>
                /*
                 * row size is odd, do last element in row s00+1,s10+1 are off
                 * edge
                 */
<span class="fc" id="L857">                b[k] = (byte) ((a.get(s10) &lt;&lt; 1 &amp; b1 | a.get(s00) &lt;&lt; N3 &amp; b3) &gt;&gt; bit);</span>
<span class="fc" id="L858">                k += 1;</span>
            }
        }
<span class="fc bfc" id="L861" title="All 2 branches covered.">        if (i &lt; nx) {</span>
            /*
             * column size is odd, do last row s10,s10+1 are off edge
             */
<span class="fc" id="L865">            s00 = n * i;</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">            for (j = 0; j &lt; ny - 1; j += 2) {</span>
<span class="fc" id="L867">                b[k] = (byte) ((a.get(s00 + 1) &lt;&lt; 2 &amp; b2 | a.get(s00) &lt;&lt; N3 &amp; b3) &gt;&gt; bit);</span>
<span class="fc" id="L868">                k += 1;</span>
<span class="fc" id="L869">                s00 += 2;</span>
            }
<span class="fc bfc" id="L871" title="All 2 branches covered.">            if (j &lt; ny) {</span>
                /*
                 * both row and column size are odd, do corner element s00+1,
                 * s10, s10+1 are off edge
                 */
<span class="fc" id="L876">                b[k] = (byte) ((a.get(s00) &lt;&lt; N3 &amp; b3) &gt;&gt; bit);</span>
<span class="fc" id="L877">                k += 1;</span>
            }
        }
<span class="fc" id="L880">    }</span>

    private void qtreeReduce(byte[] a, int n, int nx, int ny, byte[] b) {
        int i, j, k;
        int s10, s00;

<span class="fc" id="L886">        k = 0; /* k is index of b[i/2,j/2] */</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">        for (i = 0; i &lt; nx - 1; i += 2) {</span>
<span class="fc" id="L888">            s00 = n * i; /* s00 is index of a[i,j] */</span>
<span class="fc" id="L889">            s10 = s00 + n; /* s10 is index of a[i+1,j] */</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">            for (j = 0; j &lt; ny - 1; j += 2) {</span>
<span class="fc bfc" id="L891" title="All 8 branches covered.">                b[k] = (byte) (b2i(a[s10 + 1] != 0) | b2i(a[s10] != 0) &lt;&lt; 1 | b2i(a[s00 + 1] != 0) &lt;&lt; 2 | b2i(a[s00] != 0) &lt;&lt; N3);</span>
<span class="fc" id="L892">                k += 1;</span>
<span class="fc" id="L893">                s00 += 2;</span>
<span class="fc" id="L894">                s10 += 2;</span>
            }
<span class="fc bfc" id="L896" title="All 2 branches covered.">            if (j &lt; ny) {</span>
                /*
                 * row size is odd, do last element in row s00+1,s10+1 are off
                 * edge
                 */
<span class="fc bfc" id="L901" title="All 4 branches covered.">                b[k] = (byte) (b2i(a[s10] != 0) &lt;&lt; 1 | b2i(a[s00] != 0) &lt;&lt; N3);</span>
<span class="fc" id="L902">                k += 1;</span>
            }
        }
<span class="fc bfc" id="L905" title="All 2 branches covered.">        if (i &lt; nx) {</span>
            /*
             * column size is odd, do last row s10,s10+1 are off edge
             */
<span class="fc" id="L909">            s00 = n * i;</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">            for (j = 0; j &lt; ny - 1; j += 2) {</span>
<span class="fc bfc" id="L911" title="All 4 branches covered.">                b[k] = (byte) (b2i(a[s00 + 1] != 0) &lt;&lt; 2 | b2i(a[s00] != 0) &lt;&lt; N3);</span>
<span class="fc" id="L912">                k += 1;</span>
<span class="fc" id="L913">                s00 += 2;</span>
            }
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">            if (j &lt; ny) {</span>
                /*
                 * both row and column size are odd, do corner element s00+1,
                 * s10, s10+1 are off edge
                 */
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">                b[k] = (byte) (b2i(a[s00] != 0) &lt;&lt; N3);</span>
<span class="fc" id="L921">                k += 1;</span>
            }
        }
<span class="fc" id="L924">    }</span>

    private void shuffle(long[] a, int aOffet, int n, int n2, long[] tmp) {

        /*
         * int a[]; array to shuffle int n; number of elements to shuffle int
         * n2; second dimension int tmp[]; scratch storage
         */

        int i;
        long[] p1, p2, pt;
<span class="fc" id="L935">        int p1Offset = 0;</span>
<span class="fc" id="L936">        int ptOffset = 0;</span>
<span class="fc" id="L937">        int p2Offset = 0;</span>
        /*
         * copy odd elements to tmp
         */
<span class="fc" id="L941">        pt = tmp;</span>
<span class="fc" id="L942">        ptOffset = 0;</span>
<span class="fc" id="L943">        p1 = a;</span>
<span class="fc" id="L944">        p1Offset = aOffet + n2;</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">        for (i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L946">            pt[ptOffset] = p1[p1Offset];</span>
<span class="fc" id="L947">            ptOffset += 1;</span>
<span class="fc" id="L948">            p1Offset += n2 + n2;</span>
        }
        /*
         * compress even elements into first half of A
         */
<span class="fc" id="L953">        p1 = a;</span>
<span class="fc" id="L954">        p1Offset = aOffet + n2;</span>
<span class="fc" id="L955">        p2 = a;</span>
<span class="fc" id="L956">        p2Offset = aOffet + n2 + n2;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">        for (i = 2; i &lt; n; i += 2) {</span>
<span class="fc" id="L958">            p1[p1Offset] = p2[p2Offset];</span>
<span class="fc" id="L959">            p1Offset += n2;</span>
<span class="fc" id="L960">            p2Offset += n2 + n2;</span>
        }
        /*
         * put odd elements into 2nd half
         */
<span class="fc" id="L965">        pt = tmp;</span>
<span class="fc" id="L966">        ptOffset = 0;</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">        for (i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L968">            p1[p1Offset] = pt[ptOffset];</span>
<span class="fc" id="L969">            p1Offset += n2;</span>
<span class="fc" id="L970">            ptOffset += 1;</span>
        }
<span class="fc" id="L972">    }</span>

    private void startOutputingBits() {
<span class="fc" id="L975">        this.buffer2 = 0; /* Buffer is empty to start */</span>
<span class="fc" id="L976">        this.bitsToGo2 = BITS_OF_1_BYTE; /* with */</span>
<span class="fc" id="L977">    }</span>

    private void writeBdirect(ByteBuffer outfile, LongArrayPointer a, int n, int nqx, int nqy, byte[] scratch, int bit) {

        /*
         * Write the direct bitmap warning code
         */
<span class="fc" id="L984">        outputNybble(outfile, 0x0);</span>
        /*
         * Copy A to scratch array (again!), packing 4 bits/nybble
         */
<span class="fc" id="L988">        qtreeOnebit(a, n, nqx, nqy, scratch, bit);</span>
        /*
         * write to outfile
         */
        /*
         * int i; for (i = 0; i &lt; ((nqx+1)/2) * ((nqy+1)/2); i++) {
         * output_nybble(outfile,scratch[i]); }
         */
<span class="fc" id="L996">        outputNnybble(outfile, (nqx + 1) / 2 * ((nqy + 1) / 2), scratch);</span>

<span class="fc" id="L998">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>